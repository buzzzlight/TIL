# 시간 복잡도

> 계산 복잡도 이론에서 시간복잡도는 문제를 해결하는데 걸리는 시간과 입력의 함수 관계를 가리킨다. (Time Complexity)

- 시간 복잡도가 높다 ===> 느린 알고리즘
- 시간 복잡도가 낮다 ===> 빠른 알고리즘

## 좋은 알고리즘이란?

- 효율성, 성능 중요

- Input을 넣은 후 Output이 나오는 **시간**이 짧은 알고리즘

- 적은 공간과 적은 시간 ==> 공간 복잡도, 시간 복잡도
  - 요즘은 시간 복잡도만 신경써도 된다 ... 

- 개개인의 컴퓨팅 환경에 따라 같은 알고리즘이라도 측정시간이 다름 ==> 환경에 영향을 받지 않는 객관적인 기준이 필요

- 객관적인 측정을 위해 알고리즘 내부에서 기본연산이 몇 번 일어나는지 살펴본다

- 기본연산 : 단위 시간 1이 소요되는 연산 ex) 할당, 산술, 비교, 반환...

- 기본연산의 총 횟수 == 알고리즘의 소요 시간

# 빅오(Big-O) 표기법

> 입력 n이 **무한대**로 커진다고 가정하고 시간 복잡도를 간단하게 표시하는 것. **최고차항**만 남기고 계수와 상수 제거

![big-o](C:\Users\brie.kim\Desktop\Python\00_TIL\220726_\02_time_complexity\big-o.jpeg)

|  Big-O   |                             종류                             |
| :------: | :----------------------------------------------------------: |
|   O(1)   |                  단순 산술 계산( + - * / )                   |
| O(logN)  | 크기가 N인 리스트를 반절씩 순회/탐색<br />- 이진탐색(Binary Search), 분할정복(Divide & Conquer) |
|   O(N)   |         크기가 N인 리스트를 순회 <br />- 1중 for 문          |
| O(NlogN) | 크기가 N인 리스트를 반절씩 탐색*순회<br />- 높은 성능의 정렬(Merge/Quick/Heap Sort) |
|  O(N^2)  |       크기가 M, N인 2중 리스트를 순회<br />- 2중 for문       |
|  O(N^3)  |              3중 리스트를 순회<br />- 3중 for문              |
|  O(2^N)  |                 크기가 N인 집합의 부분 집합                  |
|  O(N!)   |                       크기가 N인 순열                        |

파이썬 알고리즘 인터뷰<책

파이썬의 리스트는 매우 강력하다~!

### 문제 예시

- 1부터 N까지의 합을 구하는 문제

```python
# 1부터 N까지 일일히 더하기
def get_total(n):
    total = 0
    
    for i in range(1, n + 1):
        total += i
    
    return total

print(get_total(10))
>>> 55
print(get_total(100000000)
>>> 시간 초과
```

```python
# 가우스의 합 공식 이용
def get_total(n):
    return (n * (n + 1)) // 2

print(get_total(10))
>>> 55

print(get_total(1000000000))
>>> 50000000050000000
# 시간초과 뜨지 않음
```

- 같은 Output을 만드는 알고리즘이라도, 시간복잡도에 따라 성능이 달라질 수 있다
- 내장 함수, 메서드의 시간 복잡도도 확인 할 필요가 있음
  - for문을 1번만 썼어도 무조건 O(n)인 것이 아님
  - for문 안에 O(n)의 내장함수를 사용했다면 사실상 이중 for문과 다를 것이 없음
  - [파이썬 시간복잡도](https://wiki.python.org/moin/TimeComplexity)
