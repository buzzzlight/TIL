### 메세지 지향 미들웨어 (MOM)

- MOM (Message Oridented Middleware)
- 메세지 기반의 비동기형 메세지를 전달하는 방식의 미들웨어
- 온라인 업무보다는 이기종 분산 데이터 시스템의 데이터 동기를 위해 많이 사용한다
- 즉각적인 응답을 원하는 경우가 아니라 다소 느리고 안정적인 응답을 필요로 하는 경우에 많이 사용된다

### 익스트림 프로그래밍

- 애자일 방법론 중 하나
- 소규모 개발 조직이 불확실하고 변경이 많은 요구를 접했을 때 적절한 방법
- 익스트림 프로그래밍을 구동시키는 원리는 상식적인 원리와 경험을 최대한 끌어 올리는 것
- 구체적인 실천 방법을 정의하고 있으며 개발 문서보다 소스코드에 중점을 둠

### 유스케이스 (use case)

- 연관관계 (Association) : 유스케이스와 액터간의 상호작용이 있음을 표현
- 포함관계 (Include) : 하나의 유스케이스가 다른 유스케이스의 실행을 전제로 할 때 형성되는 관계
- 확장관계 (Extend) : 확장 기능 유스케이스와 확장 대상 유스케이스 사이에 형성되는 관계
- 일반화관계 (Generalization): 유사한 유스케이스 또는 액터를 모아 추상화한 유스케이스 또는 액터와 연결시켜 그룹을 만들어 이해도를 높이기 위한 관계

### 유스케이스 다이어그램 (Use Case Diagram)

- 액터 : 시스템과 상호작용하는 모든 외부 요소 (사람, 기계, 외부시스템 등)
- 유스케이스는 사용자 측면에서의 요구사항으로, 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술
- 시스템 액터는 다른 프로젝트에서 이미 개발되어 사용되고 있으며 본 시스템과 데이터를 주고받는 등 서로 연동되는 시스템을 말함
- 액터가 인식할 수 없는 시스템의 내부의 기능을 하나의 유스케이스로 파악해서는 안됨

### 요구사항 분석

- 소프트웨어가 무엇을 해야하는가를 추적하여 요구사항 명세를 작성하는 작업
- 사용자의 요구를 추출하여 목표를 정하고 어떤 방식으로 해결할 것인지 결정하는 단계
- 소프트웨어 개발의 출발점이면서 실질적인 첫번째 단계
- 도출 - 분석 - 명세 - 확인

#### 기능적 요구사항 vs 비기능적 요구사항

- 기능적 요구사항 : 시스템이 실제로 어떻게 동작하는지에 관점을 둔 요구사항
- 비기능적 요구사항 : 시스템 구축에 대한 성능, 보안, 품질, 안정 등 실제 수행에 보조적인 요구사항

### 미들웨어 (Middleware)

- 클라이언트와 서버간의 통신을 담당하는 시스템 소프트웨어
- 이기종 하드웨어, 소프트웨어, 네트워크, 프로토콜, PC 환경, 운영체제 환경 등에서 시스템간의 표준화된 연결을 도와주는 소프트웨어
- 표준화된 인터페이스를 통하여 시스템 간의 데이터 교환에 있어 일관성을 제공
- 운영체제와 애플리케이션 사이에서 중간 매개 역할을 하는 다목적 소프트웨어
- 미들웨어 솔루션은 미들웨어의 서비스 이용을 위해 사용자가 정보 교환 방법 등의 내부 동작을 확인할 필요가 없음
- 여러 운영체제에서 응용 프로그램들 사이에 위치한 소프트웨어
- 소프트웨어 컴포넌트를 연결하기 위한 준비된 인프라 구조를 제공
- 여러 컴포넌트를 1대1, 1대 다, 다대 다 등 여러가지의 형태로 연결이 가능

# UI

### UI 구분

- CLI (Command Line Interface): 텍스트 형태 인터페이스, 정해진 명령문자열을 입력하여 시스템을 조작하는 사용자 인터페이스
- GUI (Graphical User Interface): 마우스로 선택하여 작업하는 그래픽 환경 인터페이스
- NUI (Natural User Interface): 사용자의 말이나 행동으로 기기 조작하는 인터페이스
- VUI (Voice User Interface): 사람의 음성으로 기기 조작하는 인터페이스
- OUI (Organic User Interface): 모든 사물과 사용자 간의 상호작용을 위한 인터페이스

###  UI 설계 지침

- 사용자 중심: 사용자가 이해하기 쉽고 편하게 사용할 수 있는 환경을 제공해 실 사용자에 대한 이해가 바탕이 되어야함
- 직관성(Intuitiveness) : 누구나 쉽게 이해하고 쉽게 사용할 수 있어야함
- 유효성(Effectiveness) : 정확하고 완벽하게 사용자의 목표가 달성될 수 있도록 제작해야함
- 학습성(Learnability) : 초보와 숙련자 모두가 쉽게 배우고 사용할 수 있게 제작해야함
- 유연성 (Flexibility) : 사용자의 인터랙션을 최대한 포용하고 실수를 방지할 수 있도록 제작해야함
- 일관성: 버튼이나 조작 방법을 사용자가 기억하기 빠르고 쉽게 습득할 수 있도록 설계해야함
- 단순성: 조작 방법은 가장 간단하게 작동되도록 하여 인지적 부담 최소화
- 결과 예측 가능: 작동시킬 기능만 보고도 결과 예측이 가능해야함
- 가시성: 주요 기능을 메인 화면에 노출하여 쉬운 조작이 가능해야함
- 표준화: 디자인을 표준화하여 기능 구조의 선행학습 이후 쉽게 사용 가능해야함
- 접근성: 사용자의 직무, 연령, 성별 등이 고려된 다양한 계층을 수용해야함
- 명확성: 사용자가 개념적으로 쉽게 인지해야함
- 오류 발생 해결: 사용자가 오류에 대한 상황을 정확하게 인지할 수 있어야함

### UI 설계 도구

- 스토리보드(storyboard) : 디자이너와 개발자가 최종적으로 참고하는 작업지침서, 상단이나 우측에 제목, 작성자 등을 입력하고 좌측에는 UI 화면, 우측에는 디스크립션을 기입
- 프로토타입(prototype) : 와이어 프레임이나 스토리보드 등에 인터렉션을 적용함으로써 실제 구현된 것처럼 테스트가 가능한 동적인 형태의 모형
- 유스케이스(usecase) : 사용자 측면에서 요구사항으로 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술
- 목업(mockup) : 디자인, 사용방법 설명, 평가 등을 위해 실제 화면과 유사하게 만든 정적인 형태의 유형 / 시각적으로만 구성  요소를 배치하는 것으로 일반적으로 실제로 구현되지는 않음

### 객체지향 개념

#### 다형성 (Polymorphism)

- 오버로딩 - 같은 이름의 메소드를 중복하여 정의하는 것. 하지만 매개변수나 수의 타입을 다르게 하여 재정의함
- 오버라이딩 - 상속관계에서만 발생. 슈퍼클래스의 메소드를 서브클래스에서도 동일한 메소드를 재정의 하는것

- 다형성은 현재 코드를 변경하지 않고 새로운 클래스를 쉽게 추가할 수 있게 한다
- 다형성이란 여러가지 형태를 가지고 있다는 의미로, 여러 형태를 받아들일 수 있는 특징을 말함
- 하나의 메세지에 대해 각 객체가 갖고 있는 고유한 방법대로 응답하는 것을 의미
- 하나의 클래스나 메서드가 다양한 방식으로 동작이 가능한 것을 의미

#### 캡슐화 (Encapsulation)

- 서로 관련성이 많은 데이터들과 연산들을 묶는다
- 데이터와 데이터를 처리하는 함수를 하나로 묶은 것
- 캡슐화된 객체의 세부 내용이 은폐되어 변경이 발생해도 오류의 파급효과가 적음
- 캡슐화된 객체들은 재사용이 용이함
- 인터페이스가 단순해지고 객체간의 결합도가 낮아짐

#### 상속성 (Inheritance)

- 이미 정의된 상위 클래스(부모클래스)의 모든 속성과 연산을 하위 클래스(자식 클래스)가 물려받는 것
- 하위클래스는 상위클래스로부터 받은 속성과 연산 외에도 새로운 것을 첨가 가능
- 클래스의 재사용, 소프트웨어의 재사용을 높이는 중요한 개념
- 속성과 연산 등을 물려주는 클래스를 상위클래스 또는 슈퍼클래스, 물려받는 클래스를 하위클래스 또는 서브 클래스라고 한다.

#### 추상화 (abstraction)

- 데이터들의 공통된 성질을 추출해 슈퍼클래스 선정

### 객체지향

- 객체(object)란 필요한 자료 구조와 수행되는 함수들을 가진 하나의 독립된 존재
- 상속(Inheritance)은 개별 클래스를 상속관계로 묶음으로써 클래스 간의 체계화된 전체구조를 파악하기 쉽다는 장점이 있다
- 같은 클래스에 속하는 개개의 객체이자 하나의 클래스에서 생성된 객체를 인스턴스(instance)라고 한다

### 객체지향 분석기법

- Rumbaugh Method 럼바우 방법
  - 모든 소프트웨어 구성요소를 그래픽 표기법을 이용하여 모델링하는 기법으로, 객체 모델링 기법(Object Modeling Technique)라고도 함. 분석활동은 객체모델링 -> 동적 모델링 -> 기능모델링 순으로 이루어짐
- Booch Method 부치 방법
  - 미시적(Micro) 개발 프로세스와 거시적(Macro) 개발 프로세스를 모두 사용하는 분석 방법으로 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의한다
- Jacobson Method
  - use case를 강조하여 사용하는 분석방법
- Coad와 Yourdon Method
  - E-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체식별, 구조식별 ,주제정의, 속성과 인스턴스 연결정의, 연산과 메시지 연결 정의 등의 과정으로 구성하는 기법
- Wirfs-Brock Method
  - 분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행하는 기법
- 객체지향은 상향식

### 객체

- 클래스는 공통 속성을 공유하는 객체들의 집합
- 객체는 상태, 동작, 고유 식별자를 가진 모든것이라 할 수 있다
- 객체는 필요한 자료 구조와 이에 수행되는 함수들을 가진 하나의 독립된 존재
- 객체의 상태는 속성값에 의해 정의됨

### 클래스

- 클래스: 하나 이상의 유사한 객체들을 묶는다
- 연관관계(Association): 2개 이상의 사물이 서로 관련되어 있음을 표현
- 단일 책임원칙 : 하나의 객체는 하나의 동작만의 책임을 가짐
- 개방-폐쇄의 원칙 : 클래스는 확장에 대해 열려있어야 하며 변경에 대해 닫혀있어야 한다
- 리스코프 교체의 원칙 : 특정 메소드가 상위 타입을 인자로 사용할 때, 그 타입의 하위 타입도 문제없이 작동해야함
- 의존관계 역전의 원칙 : 상위 계층이 하위 계층에 의존하는 전통적인 의존관계를 반전(역전)시킴으로써 상위 계층이 하위 계층의 구현으로부터 독립되게 할 수 있음

### UML 다이어그램 분류

- 정적(구조적) 다이어그램 : 클객컴배복패
  - 클래스, 객체, 패키지, 컴포넌트, 복합구조, 배치
- 동적 다이어그램
  - 유스케이스, 상태, 활동, 시퀀스, 통신, 상호작용, 타이밍
- 클래스 다이어그램 : 객체를 생성하기 위한 도구
- 객체 다이어그램 : 객체 간의 연결관계를 표현
- 패키지 다이어그램 : 객체들의 그룹화된 표현
- 컴포넌트 다이어그램 : 시스템을 구성하는 컴포넌트 사이의 의존관계를 표현, 컴포넌트는 1개 이상의 클래스로 구현됨
- 복합구조 다이어그램: 컴포넌트나 클래스의 내부 구조를 보여주기 위해 사용, 내부 연결 형태를 표현
- 배치 다이어그램 : H/W자원에 연결된 S/W 컴포넌트 배치를 표현
- 유스케이스 다이어그램: 사용자의 시각에서 소프트웨어의 범위와 기능을 표현
- 상태 다이어그램: 시간에 따라 객체가 변하는 상태를 표현
- 활동 다이어그램 : 객체의 동적 행위를 활동으로 표현
- 시퀀스 다이어그램: 객체간 상호작용을 시간 순서에 따른 메세지로 표현
- 통신 다이어그램: 객체간 상호작용을 관계형태의 메세지로 표현
- 상호작용 다이어그램: 객체들의 상호작용 관계를 표현
- 타이밍 다이어그램: 객체간 상태변화를 구체적인 시간으로 표현

# 애자일 (Agile)

### 애자일 프로세스 모델

- 개발에 대한 개념적 방법론으로, 개발 프로젝트 기간을 짧은 주기로 나눠 반복적인 개발을 하는 것이 특징
- 고객관점의 효율적이고 민첩한 변화 대응을 중시
- 프로세스, 도구 보다는 사람과 상호작용을
- 광범위한 문서 보다는 실제 작동하는 제품을
- 계약 협상보다는 고객 협력을
- 계획을 따르기 보다는 변화 대응을
- 프로젝트 요구사항은 ''기능'' 중심
- 공정과 도구보다 개인과의 ''소통'' 중요시
- ''변화''에 유연하고 신속한 대처
- ''고객''과의 피드백을 중요시

### 스크럼 (Scrum)

- 스크럼 마스터 (scrum master)는 스크럼 프로세스를 따르고, 팀이 스크럼을 효과적으로 활용할 수 있도록 보장하는 역할 등을 맡는다
- 제품 백로그(Product backlog)는 스크럼 팀이 해결해야 하는 목록으로 소프트웨어 요구사항, 아키텍처 정의 등이 포함될 수 있다
- 스프린트(sprint)는 실제 개발을 2-4주간 진행하는 과정으로 스프린트 백로그에 작성된 task를 대상으로 작업 시간을 측정한 후 담당 개발자에게 할당함. task는 할일, 진행중, 완료의 상태로 구성됨
- 속도(velocity)는 한번의 스프린트에서 한 팀이 어느정도의 제품 백로그를 감당할 수 있는지에 대한 추정치로 볼 수 있다

### 컴포넌트

- 프로그래밍에 있어 재사용이 가능한 각각의 독립된 모듈
- 특정 기능 수행을 위해 독립적으로 분리
- 명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분으로 넓은 의미에서는 재사용 되는 모든 단위라고 볼 수 있으며, 인터페이스를 통해서만 접근할 수 있음

### MVC (Model-View-Controller)

- 한개의 모델에 대해 여러개의 뷰를 만들 수 있음
- 모델은 서브 시스템의 핵심 기능과 데이터를 보관하며 MVC 패턴에서는 여러개의 뷰를 만들 수 있으므로 한개의 모델에 대해 여러개의 뷰를 필요로 하는 대화형 어플리케이션에 적합
- 전달자 역할은 모델(model)이 아닌 제어(controller)

- MVC 모델은 사용자 인터페이스를 담당하는 계층의 응집도를 높일 수 있고 여러개의 다른 UI를 만들어 그 사이의 결합도를 낮출 수 있다
- 뷰는 모델에 있는 데이터를 사용자 인터페이스에 보이는 역할을 담당한다
- 제어는 모델에 명령을 보냄으로써 모델의 상태를 변경할 수 있다

### 통합 테스트 (Integration Test)

- 상향식 통합 테스트 (Botton Up Intergration Test)
  - 프로그램의 하위 모듈에서 상위 모듈 방향으로 통합하며 테스트
  - 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹인 클러스터(Cluster) 필요 (스텁 필요 x)
  - 절차
    - 하위 모듈을 클러스터로 결합
    - 상위 모듈에서 데이터의 입출력을 확인하기 위해 모듈인 드라이버 작성
    - 통합된 클러스터 단위로 테스트
    - 테스트가 완료되면 클러스터는 프로그램 구조의 상위로 이동하여 결합하고 드라이버는 실제 모듈로 대체
- 하향식 통합 테스트 (Top Down Intergration Test)
  - 상위 모듈에서 하위 모듈 방향으로 통합하며 테스트
  - 깊이 우선 통합법, 넓이 우선 통합법 사용
  - 초기부터 사용자에게 시스템 구조를 보여줌
  - 상위 모듈에서는 tc를 사용하기 어려움
  - 절차
    - 주요 제어 모듈은 작성된 프로그램을 사용하고 주요 제어 모듈의 종속 모듈들은 스텁(stub)으로 대체
    - 깊이 우선 or 넓이 우선 등의 통합방식에 따라 하위모듈인 스텁들이 한번에 하나씩 실제 모듈로 교체됨
    - 모듈이 통합될 때마다 테스트 실시
    - 새로운 오류가 발생하지 않음을 보증하기 위해 회귀 테스트 실시

### 워크스루(Walkthrough)

- 요구사항 명세서 작성자를 포함하여 사전 검토한 후에 짧은 검토 회의를 통해 결함 발견
- 사용사례를 확장하여 명세하거나 설계 다이어그램, 원시코드, 테스트 케이스 등에 적용할 수 있음
- 복잡한 알고리즘 또는 반복, 실시간 동작, 병행 처리와 같은 기능이나 동작을 이해하려고 할 때 유용
- 단순한 테스트 케이스를 이용하여 프로덕트를 수작업으로 수행해보는 것

### 인스펙션

- 요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 요구사항 명세서를 확인하면서 결함 발견

### 소프트웨어 개발과정

- 복호화 - 디코딩, 즉 부호화된 데이터를 부호화 되기 전 형태로 바꾸어 사람이 읽을 수 있는 형태로 되돌려 놓는 것
- 저작권 - 창작물을 만든이가 자기 저작물에 대해 가지는 법적 권리
- 크랙 - 소프트웨어를 수정하여 소프트웨어를 크랙하는 사람이 원하지 않는 기능들, 보통은 수정 방식 (복사 보호, 소프트웨어 조작 보호)을 비활성화하거나 제거하는 일

- 형상 관리 - 소프트웨어 개발과정에서 소프트웨어의 변경사항을 관리하기 위해 개발된 일련의 활동

### 소프트웨어 아키텍처의 설계과정

- 설계 목표 설정 - 시스템 타입 결정 - 아키텍처 패턴 적용(스타일 적용 및 커스터마이즈) - 서브시스템 구체화(서브시스템의 기능, 인터페이스 동작 작성) - 아키텍처 설계 검토

### 소프트웨어 묘듈화

- 프로그램의 효율적 관리
- 이해하기 쉬운 소프트웨어
- 소프트웨어 테스트, 통합, 수정 시 용이
- 모듈 재사용 가능 -> 개발과 유지보수 용이
- 오류의 파급력 최소화

### 소프트웨어 테스트

- 검증 (verificaiton) : 소프트웨어가 요구사항에 부합하게 구현되었음을 보장하는 활동
- 확인 (Validation) : 소프트웨어가 고객의 의도에 따라 구현되었음을 보장하는 활동

### 테스트 케이스

- 구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 입력값, 실행조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서를 의미
- 테스트의 목표 및 테스트 방법을 결정하고 테스트 케이스를 작성해야함
- 프로그램에 결함이 있더라도 입력에 대해 정상적인 결과를 낼 수 있기 때문에 결함을 검사할 수 있는 테스트 케이스를 찾는게 중요하다
- 개발된 서비스가 정의된 요구사항을 준수하는지 확인하기 위한 입력값과 실행 조건, 예상 결과의 집합으로 볼 수 있다
- 테스트 케이스 실행이 통과되었는지 실패하였는지 판단하기 위한 기준을 테스트오라클 이라고 한다

### 소프트웨어 재공학

- Analysis : 기존 소프트웨어를 분석하여 재공학 대상을 선정하는 것
- migration : 기존 소프트웨어를 다른 운영체제나 하드웨어 환경에서 사용할 수 있도록 변환하는 작업
- restructuring : 기존 소프트웨어를 향상시키기 위하여 코드를 재구성하는 작업(기능과 외적 동작은 변하지 않음)
- reverse engineering : 기존 소프트웨어를 분석하여 소스코드를 얻어내는 작업  (소스코드로 소프트웨어를 만드는 작업의 역 작업)

### 소프트웨어 패키징

- 패키징은 소비자 중심으로 진행한다
- 모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것
- 개발자가 아니라 사용자 중심으로 진행함
- 소스코드는 향후 관리를 고려하여 모듈화하여 패키징함
- 사용자가 소프트웨어를 사용하게 될 환경을 이해하여 다양한 환경에서 소프트웨어를 손쉽게 사용할 수 있도록 일반적인 배포 형태로 패키징함
- 사용자를 중심으로 진행되는 작업이므로 사용자의 편의성 및 실행환경을 우선적으로 고려해야함

### 소프트웨어 재사용

#### 장점

- 개발 시간과 비용 단축
- 소프트웨어 품질 및 생산성 향상
- 프로젝트 실패 위험 감소
- 시스템 구축 방법에 대한 지식 공유

#### 단점

- 재사용할 소프트웨어 선정 필요
- 시스템에 공통적으로 사용되는 요소 발견 필요
- 프로그램의 표준화 부족
- 새로운 개발 방법론 도입이 어려움
- 재사용을 위한 관리 및 지원 부족
- 기존 소프트웨어에 재사용 소프트웨어를 추가하기 어려움

### 소프트웨어 설계

- 좋은 소프트웨어일수록 모듈간의 결합도는 낮고, 모듈 내 요소 간 응집도는 높다
- 결합도: 어떤 모듈이 다른 모듈에 의존하는 정도
- 응집도: 한 모듈 내부의 처리 요소들이 서로 관련되어 있는 정도 (독립적 기능 수행 정도)

### DRM (Digital Rights Management)

- 디지털 콘텐츠의 지적재산권보호, 관리 기능 및 안전한 유통과 배포를 보장하는 솔루션
- 디지털 콘텐츠의 지적재산권을 보호하는 권한통제기술, 사용권한제어기술, 패키징기술, 라이선스 관리를 포함한 유통체계
- 디지털 콘텐츠와 디바이스의 사용을 제한하기 위해 하드웨어 제조업자, 저작권자, 출판업자 등이 사용할 수 있는 접근제어기술을 의미
- 디지털 미디어의 생명주기동안 발생하는 사용권한권리, 과금, 유통단계를 관리하는 기술
- 클리어링 하우스(Clearing House)는 사용자에게 콘텐츠 라이센스를 발급하고 권한을 부여해주는 시스템



- 위험 모니터링
  - 위험 요소 징후들에 대하여 계속적으로 인지하는 것



- RCS (Revision Control System)
  - CVS와의 차이점은 소스 파일의 수정을 한 사람만으로 제한
  - 다수의 사용자가 동시에 파일 수정을 할 수 없도록 파일 잠금 방식으로 버전을 관리하는 도구
  - 다른 방향으로 진행된 개발 결과를 합치거나 변경 내용을 추적할 수 있다
- RPC (Remote Procedure call)
  - 별도의 원격 제어를 위한 코딩 없이 다른 주소 공간에서 리모트의 함수나 프로시저를 실행 할 수 있게 해주는 프로세스간 통신

### 화이트박스 테스트

- 화이트박스 테스트의 이해를 위해 논리흐름도(Logic-Flow Diagram)를 이용할 수 있다
- 테스트 데이터를 이용해 실제 프로그램을 실행함으로써 오류를 찾는 동적 테스트(Dynamic Test)에 해당
- 테스트 데이터를 선택하기 위해 검증기준(Test Coverage)을 정한다

#### 화이트박스 테스트의 종류

- 기초경로 검사 (Basic Path Testing)
- 제어구조 검사
- 조건 검사 (Condition Testing)
- 루프 검사 (Loop Testing)
- 데이터 흐름 검사 (data flow testing)

#### 화이트박스 테스트 검증 기준

- 문장 검증 기준
- 분기 검증 기준
- 조건 검증 기준
- 분기/조건 기준

### 블랙박스 테스트

- 프로그램의 구조를 고려하지 않기 때문에 테스트 케이스는 프로그램 또는 모듈의 요구나 명세를 기초로 결정

#### 블랙박스 테스트 종류

- 동치(동등) 분할 검사
- 경계값 분석
- 원인-효과 검사
- 오류 예측 검사
- 비교검사

### 버블 정렬

- 첫 위치부터 시작해서 오른쪽 값과 비교

```
9, 6, 7, 3, 5 비교

PASS 1
9, 6 비교 -> 69735
9, 7 비교 -> 67935
9, 3 비교 -> 67395
9, 5 비교 -> 67359
```

### 인스펙션(Inspection) 과정

- 계획 -> 사전교육 -> 준비 -> 인스펙션 회의 -> 수정 -> 후속조치

### 통합 테스트 (Integration Test)

- 모듈을 통합하는 과정에서 모듈 간의 호환성을 확인하기 위해 수행되는 테스트

### 시스템 테스트

- 완전한 시스템에 대해 수행하는 테스트
- 기능적, 비기능적 요구사항을 만족하는지 확인

### 인수 테스트 (Acceptance Test)

- 실제 환경에서 사용자가 참여하는 테스트
- 요구 분석 명세서에 나타난 사항을 모두 충족하는지, 시스템이 예상대로 동작하는지 사용자의 관점에서 확인

### 단위 테스트 (Unit Test)

> 하나의 모듈을 기준으로 독립적으로 진행되는 가장 작은 단위의 테스트 / 내부에 존재하는 논리적인 오류를 검출, 기능이 제대로 수행되는지 점검

- 테스트 드라이버 (test driver)
  - 필요 데이터를 인자를 통해 넘겨주고 테스트 완료 후 그 결과값을 받는 역할을 하는 가상의 모듈
  - 테스트 대상 하위 모듈을 호출하고, 파라미터 전달, 모듈 테스트 수행 후의 결과 도출
  - 상향식 테스트에 사용됨

- 테스트 스텁 (test stub)
  - 인자를 통해 받은 값을 가지고 수행한 후 그 결과를 테스트할 모듈에 넘겨주는 역할을 함

  - 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로, 일시적으로 필요한 조건만을 가지고 있는 테스트용 모듈

  - 하향식 테스트에 사용됨

- 테스트 슈트 (test suites) : 테스트 대상 컴포넌트나 모듈, 시스템에 사용되는 테스트 케이스의 집합
- 테스트 케이스 (test case) : 사용자의 요구사항을 정확히 준수했는지 확인하기 위한 입력값, 실행 조건, 기대결과 등으로 만들어진 테스트 항목의 명세서
- 구현 단계에서 각 모듈의 개발을 완료한 후 개발자가 명세서의 내용대로 정확히 구현되었는지 테스트한다
- 모듈 내부의 구조를 구체적으로 볼 수 있는 구조적 테스트를 주로 시행
- 테스트할 모듈을 호출하는 모듈도 있고, 테스트할 모듈이 호출하는 모듈도 있음
- CppUnit - C++ 프로그래밍 언어용 단위 테스트 도구
- JUnit - 자바 프로그래밍 언어용 단위 테스트 도구
- HttpUnit - 웹 브라우저 없이 웹사이트 테스트를 수행하는데 사용되는 오픈소스 소프트웨어 테스트 프레임워크

### IDE (Integrated Development Environment)

- compile - 고급언어(사람이 인식하는 언어)에서 저급언어(기계어)로 변환하는 기능, 주어진 언어로 작성된 컴퓨터 프로그램을 다른 언어의 동등한 프로그램으로 변환하는 기능



- 후위 순회(PostOrder) - 왼 오 루트 순서
- 중위 순회(InOrder) - 왼 루트 오 순서
- 전위 순회(PreOrder) - 루트 왼 오 순서

### JSON (JavaScript Object Notation)

- 속성-값 쌍(Attribute-Value Pairs)으로 이루어진 데이터 오브젝트를 전달하기 위해 사용하는 개방형 표준 포맷
- AJAX(Asynchronous Javascript and XML)에서 많이 사용되고 XML을 대체하는 주요 데이터 포맷
- 언어 독립형 데이터 포맷으로 다양한 프로그래밍 언어에서 사용되고 있음

### list

- stack 스택: 순서가 있는 리스트에서 데이터의 삽입(Push), 삭제(Pop)가 한쪽 끝에서 일어나며 LIFO(Last-In-First-Out)의 특징을 가지는 자료구조, 인터렙트 처리, 서브루틴 호출 작업 등에 응용됨
  - overflow 오버플로우 : 스택 공간이 가득 찼을 때 하나의 데이터를 더 넣으려고 하는 경우, 스택오버플로우가 일어나고 프로그램에 오류 야기
  - underflow 언더플로우 : 스택 공간에 데이터가 없는데 프로그램에서 스택에서 데이터를 꺼내려고 하는 경우 스택언더플로우가 일어나며 프로그램에 오류를 야기

- queue 큐: FiFO, 양방향에서 일어남
- deque 덱 : 선형리스트의 양쪽 끝에서 삽입과 삭제가 모두 가능한 자료구조
- 스택, 큐, 덱, 리스트는 선형구조
- tree, graph는 비선형구조
- 순차파일, 색인파일, 직접파일은 파일구조

### 정규화 과정

- 도부이결다조
- 제1정규형 (1NF) : 모든 **도**메인이 원자 값으로만 구성, 릴레이션에 속한 모든 속성의 도메인이 원자값으로만 구성
- 제2정규형 2NF : 기본키가 아닌 속성이 기본키에 대한 완전 함수적 종속을 만족, **부**분적 함수 종속을 제거한 정규형 / 제1정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속되면 제2정규형에 속한다 (부분함수종속제거)
- 제3정규형 3NF : 제2정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 대해 **이**행적 함수 종속 관계를 만족하지 않는 정규형
- BCNF (보이스/코드) 정규형 : 릴레이션의 함수 종속 관계에서 모든 **결**정자가 후보키인 정규형, 종속성 보존 X
- 제4정규형 4NF : BCNF 정규형을 만족하면서 **다**치 종속이 성립하는 경우, R의 모든 속성이 A에 함수적 종속 관계를 만족
- 제5정규형 5NF : 제 4정규형을 만족하면서 모든 **조**인 종속이 R의 후보키를 통해서만 성립되는 정규형



# 트랜잭션

- 원자성(Atomicity) : 완전하게 수행 완료되지 않으면 전혀 수행되지 않아야함
- 일관성(Consistency): 시스템의 고정 요소는 트랜잭션 수행 전후에 같아야함
- 격리성(Isolation, 고립성): 트랜잭션 실행 시 다른 트랜잭션의 간섭을 받지 않아야함
- 영속성(Durability, 지속성): 트랜잭션의 완료 결과가 데이터베이스에 영구히 기억됨

### 트랜잭션의 상태

- Partially Committed: 마지막 연산이 실행된 직후의 상태로 아직 commit 연산 실행 전

- Committed: 트랜잭션이 실행을 성공적으로 완료하여 commit 연산을 수행한 상태
- active
- aborted : 철회 (rollback 했을때)
- failed

## 분산 데이터베이스 시스템

> Distributed Database System

- 논리적으로는 하나의 시스템에 속하지만 물리적으로는 여러개의 컴퓨터 사이트에 분산되어 있다
- 위치 투명성, 중복 투명성, 병행 투명성, 장애 투명성을 목표로 한다
- 데이터베이스의 설계가 비교적 어렵고, 개발 비용과 처리 비용이 증가한다는 단점이 있다

###  분산 데이터베이스 주요 구성 요소

- 분산 트랜잭션
- 분산 처리기
- 분산 데이터베이스
- 통신 네트워크

### 분산 데이터베이스의 목표

- 위치 투명성(Location Transparency)
  - 하드웨어와 소프트웨어의 물리적 위치를 사용자가 알 필요가 없음

- 중복(복제) 투명성(Replication Transparency)
  - 사용자에게 통지할 필요 없이 시스템 안에 파일들과 자원들의 부가적인 복사를 자유롭게 할 수있다

- 병행 투명성(Concurrency Transparency) 
  - 다중 사용자들이 자원들을 자동으로 공유할 수 있다

- 장애 투명성(Faiure Transparency)
  - 사용자들은 어느위치의 시스템에 장애가 발생했는지 알 필요가 없다


### 병행제어의 목적

- 여러 사용자들의 데이터베이스 공동 사용을 최대화
- 사용자의 응답시간 최소화
- 데이터베이스 시스템의 활용도 최대화
- 데이터베이스 일관성 유지

### 데이터 사전(data dictionary)

- 시스템 자신이 필요로 하는 여러가지 객체(기본테이블, 뷰, 인덱스, 데이터베이스, 패키지, 접근 권한 등)에 관한 정보를 포함하고 있는 시스템 데이터베이스
- 시스템 카탈로그(System Catalog), 메타 데이터(Meta Data)라고도 함
- 시스템 카탈로그 자체도 시스템 테이블로 구성되어 있어 SQL 문을 이용하여 내용 검색이 가능
- 사용자가 시스템 카탈로그를 직접 갱신할 수 없음
- SQL문으로 여러가지 객체에 변화를 주면 시스템이 자동으로 갱신

# SQL

- DML (data manipulation language 데이터 조작어)
  - 데이터베이스 사용자가 응용 프로그램이나 질의어를 통하여 저장된 데이터를 실질적으로 처리하는데 사용되는 언어, 데이터베이스 사용자와 데이터베이스 관리시스템 간의 인터페이스를 제공
  - SELECT : 테이블에서 조건에 맞는 튜플 검색
  - INSERT : 테이블에 새로운 튜플 삽입
  - UPDATE : 테이블에서 조건에 맞는 튜플의 내용 갱신(변경)
  - DELETE : 테이블에서 조건에 맞는 튜플 삭제, 테이블의 행을 삭제할 때 사용, DELETE FROM 테이블 WHERE 조건
  
- DCL (data control language 데이터 제어어)
  - 데이터의 보안, 무결성, 회복, 병행 수행 제어 등을 정의하는데 사용되는 언어 / 데이터베이스 관리자가 데이터관리를 목적으로 사용
  - COMMIT : 명령에 의해 수행된 결과를 실제 물리적 디스크로 저장하고, 데이터베이스 조작 작업이 정상적으로 완료 됐음을 알려주는 명령어
  - ROLLBACK : 아직 commit 되지 않은 변경된 모든내용들을 취소하고 데이터베이스를 이전 상태로 되돌리는 명령어
  - GRANT : 데이터베이스 사용자에게 사용 권한 부여
  - REVOKE : 데이터베이스 사용자의 사용 권한 취소

- DDL (data define language, 데이터 정의어)
  - SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의하거나 변경 또는 삭제할 때 사용하는 언어
  - CREATE : SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의한다
  - ALTER : TABLE에 대한 정의를 변경하는데 사용
  - DROP : 삭제

- DISTINCT - 중복값 제거
- CASCADE
  - 데이터베이스 내의 임의의 다른 테이블과 primary key 또는 foreign key로서의 관계가 여전히 존재하는 경우 primary key가 존재하는 테이블을 마음대로 제거 및 비활성화 할 수 없음
  - 부모테이블과 자식테이블 간에 참조설정이 되어 있을 때 부모테이블의 제약 조건을 비활성화 시키면서 이를 참조하고 있는 자식 테이블의 제약 조건까지 함께 비활성화시키기 위해 사용
  - 부모 테이블만 삭제하고 싶을 경우, 원래는 자식테이블을 먼저 삭제하고 부모를 삭제한뒤 자식을 다시 만들어야 하는 번거로움이 따른다 하지만 cascade를 쓰면 일시적으로 참조관계를 끊을 수 있다

- CREATE TABLE 문
  - PRIMARY KEY - 기본키 정의 / 유일하게 테이블의 각 행을 식별
  - FOREIGN KEY - 참조 대상을 테이블로 명시 / 외래키를 정의 / 열과 참조된 테이블의 열 사이의 외래 키 관계를 적용하고 설정
  - UNIQUE - 테이블 내에서 얻은 유일한 값을 갖도록 하는 속성
  - NOT NULL - 해당 컬럼은 NULL값을 포함하지 않도록 하는 속성
  - CHECK - 개발자가 정의하는 제약조건 / 참이어야 하는 조건을 지정
  - DEFAULT - 해당 필드의 기본값을 설정


### KEY

> 레코드 또는 튜플을 확인하기 위해 이용되는 속성값

- atomic key
- super key 슈퍼 키
  - 속성들의 집합으로 구성된 키
  - 릴레이션을 구성하는 모든 튜플들 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않음
  - 데이터베이스에서 테이블의 행을 고유하게 식별할 수 있는 속성 or 속성의 집합

- candidate key - 후보 키
  - 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합, 유일성과 최소성을 만족하는 속성
  - 슈퍼키 중 최소성을 만족하는 것이 후보키가 됨
  - 후보키는 기본키로 사용할 수 있으며 후보키가 여러개일 경우엔 하나를 지정해 사용
  - 지정되지 않은 나머지 후보키 = 대체 키(alternate key)

- test key
- primary key - 기본 키, 후보키 중에서 선정된 주키(main key)로 중복된 값을 가질 수 없음
  - 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성
  - 기본키는 후보키의 성질을 갖는다. 즉 튜플을 식별하기 위해 반드시 필요한 키
  - 기본키는 NULL값을 가질 수 없음
  - 테이블의 각 레코드를 고유하게 식별하는 필드나 필드의 집합
  - 테이블에 기본키 설정은 필수 가 아님
  - 기본키를 설정하지 않고도 다른 테이블과 관계를 설정할 수 있다
  - 기본키는 혼합속성(다수필드)에 설정할 수 있다
  - 값의 변화가 거의 없고 단순한 후보키가 기본키로 적합함
- foreign key 외래키
  - 관계형 데이터베이스에서 한 테이블 속성 집합이 다른 테이블의 기본키가 됨
  - 데이터베이스 내에 존재하는 테이블들의 관계에서 참조의 무결성을 보장하기 위함
  - 중복되는 값, null값을 가질수있음


## 무결성 제약조건

- 개체무결성 - 각 릴레이션의 기본키를 구성하는 속성은 NULL값이나 중복된 값을 가질 수 없음
- 참조무결성 - 외래키 값은 null이거나 참조하는 릴레이션의 기본키 값과 동일해야함
- 도메인 무결성 - 속성들의 값은 정의된 도메인에 속한값이어야함
- 고유 무결성 - 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우, 릴레이션의 각 튜플이 가지는 속성 값들은 서로 달라야함
- null 무결성 - 릴레이션의 특정 속성 값은 null이 될 수 없음
- 키 무결성 - 각 릴레이션은 최소 한개 이상의 키가 존재해야함



# 데이터베이스

## 설계 단계

### 트랜잭션 설계 단계

- 개념적 설계
  - 트랜잭션 모델링
  - 독립적인 개념 스키마 모델링
  - 개념스키마 설계
  - E-R 다이어그램
- 논리적 설계
  - 트랜잭션 인터페이스 설계
  - DBMS에 맞는 논리스키마 설계
  - 테이블 설계
  - 논리적 매핑
  - 스키마 평가 및 정제
- 물리적 설계
  - 트랜잭션 세부설계
  - 레코드 집중의 분석 설계
  - 저장레코드 양식 설계
  - 저장 구조 및 액세스 경로 설정
  - 어떤 인덱스를 만들 것인지에 대한 고려
  - 성능 향상을 위한 개념 스키마의 변경 여부 검토
  - 레코트의 크기
  - 파일과 구조저장을 위한 최소한의 공간
  - 빈번한 질의와 트랜잭션들의 수행 속도를 높이기 위한 고려사항 (응답시간, 저장 공간의 효율화, 트랜잭션 처리량)

## 데이터 모델

### 데이터 모델링의 구성요소

- 논리적 구조 (Relation) 
- 연산 (Operation) : 실제 데이터를 처리하는 작업에 대한 명세로, 조작하는 기본 도구
- 제약조건 (Constraint) : DB에 저장될 수 있는 실제 데이터의 논리적인 제약 조건
- 구조 (Struture) : 논리적인 개체 타입들 간의 관계, 데이터 구조 및 정적 성질을 표현

### 논리 데이터 모델의 구성요소

- 개체
- 속성
- 관계

### 자료 흐름도(DFD)

- process (처리) - 원
- data flow (자료 흐름) - 화살표
- data store (자료저장소) - 평행선
- terminal (단말) - 사각형

### E-R 모델

- 관계 - 마름모
- 개체 - 사각형
- 관계-속성 연결 - 선
- 다중값 속성 - 원두개

# C언어

## 문자열 처리 함수

- strlen(s) - s의 길이를 구한다
- strcpy(s1, s2) - s2를 s1으로 복사
- strcmp - 문자열 비교
- strcat - 문자열 연결
- strrev(s) - s를 거꾸로 변환

## 연산

- a && b : and 연산 (둘다 참이어야 1 반환)
- a || b : or 연산 (한쪽만 참이어도 1 반환)
- !c : not 연산 (참 1 반환, 부정 0 반환)
- ** : 거듭제곱

# JAVA

### 예외 (exception)

- 오동작이나 결과에 악영향을 미칠 수 있는 실행 시간 동안에 발생한 오류
- 배열의 인덱스가 그 범위를 넘어서는 경우 발생하는 오류
- 존재하지 않는 파일을 읽으려고 하는 경우에 발생하는 오류

### 연산

- -- > % > & > =

### UDP(user datagram protocol)

- 비연결형 및 비신뢰성 전송 서비스를 제공한다
- 흐름 제어나 순서 제어가 없어 전송 속도가 빠르다
- 수신된 데이터의 순서 재조정 기능을 지원하지 않음
- 복구 기능을 제공하지 않음
- 단순한 헤더 구조로 오버헤드가 적음
- TCP와 같이 트랜스포트 계층에 존재

### 응집도

- (강) 기능적 응집도 > 순차적 응집도 > 교환적 응집도 > 절차적 응집도 > 시간적 응집도 > 논리적 응집도 > 우연적 응집도 (약)

### 악성코드

- Worm - 다른 컴퓨터의 취약점을 이용하여 스스로 전파하거나 메일로 전파되며 스스로를 증식
- Rogue Ware(Rogue security software 가짜 백신 소프트웨어) - 사용자가 컴퓨터에 바이러스가 있다고 잘못 믿게 하고 컴퓨터에 실제로 악성프로그램을 설치토록 하거나 가짜 악성 프로그램 제가 도구에 대한 비용을 지불하도록 설득. 공포심을 통해 사용자를 조종
- Adware - 특정 소프트웨어를 실행할 때 또는 자동으로 활성화되는 광고프로그램으로 이 자체는 악성코드로 보기는 힘들지만 무분별한 광고 팝업을 뜨게 하는 등 악용 위험성으로 악성코드로 분류되기도 함
- Reflection Attack (반사공격) - 송신자가 생성한 메세지를 가로챈 공격자가 그 메세지를 다시 송신자에게 재전송하여 접근 권한을 얻는 형태의 공격 방법



- Authorization - 권한 부여
- Authentication - 신원 증명 (아이디 패스워드 입력)



### LOC 기법

- (총 라인수 / 월간 평균 생산 라인 수) / 참여프로그래머 수 = 몇개월



## 디자인패턴

> 객체지향 프로그래밍 설계를 할 때 자주 발생하는 문제들을 피하기 위해 사용되는 패턴

### GoF (Gangs of Four) 디자인 패턴

#### 생성패턴

- 추상팩토리 (Abstract Factory)
- 빌더 (Builder)
- 팩토리메소드 (Factory Method)
- 프로토타입 (Prototype)
- 싱글톤 (Singleton)

#### 구조패턴

- 어댑터 (Adapter)
- 브릿지 (Bridge)
- 컴포지트 (Composite)
- 데코레이터 (Decorator)
- 파사드 (Facade)
- 플라이웨이트 (Flyweight)
- 프록시 (Proxy)

#### 행위패턴

- 책임연쇄 (Chain of Responsibility)
- 커맨드 (Command)
- 인터프리터 (InterPreter)
- 이터레이터 (Iterator)
- 중재자 (Mediator)
- 메멘토 (Memento)
- 옵서버 (Observer)
- 상태 (State)
- 전략 (Strategy)
- 템플릿메서드 (Template Method)
- 방문자 (Visitor)





- Method 메서드 : 클래스로부터 생성된 객체를 사용하는 방법, 객체가 메시지를 받아 실행해야할 객체의 구체적인 연산
- Message 메시지 : 객체 간 상호 작용을 하기 위한 수단, 객체에게 어떤 행위를 하도록 지시하는 방법
- Class 클래스 : 특정 객체 내에 있는 변수와 메서드를 정의하는 일종의 틀, 객체 지향 프로그래밍에서 데이터를 추상화하는 단위
- Field 필드 : SQL에서 열 또는 속성이라고 불리는 것

### 정형기술검토(FTR)

- 오류 검출에 초점을 두고 해결책을 나중으로 미룸(제품 검토의 집중성)
- 검토를 위한 자료를 사전에 배포하여 검토하도록 함(사전 준비성)
- 의견을 제한하되 충분히 받아들인다 (의제의 제한성)

- 안건을 세우면 고수한다 (안건 고수성)
- 논쟁과 반박을 제한한다(논쟁 반박의 제한성)
- 문제 영역을 공개한다 (문제 공개성)
- 참가자 수를 제한한다 (참가 인원의 제한성)
- 발견된 오류는 문서화한다 (문서성)



- 프로그래밍 언어의 선정 기준
  - 친밀감, 언어의 능력, 처리의 효율성, 프로그램 구조, 프로그램의 길이, 이식성, 과거 개발실적, 알고리즘과 계산 난이도, 자료구조 난이도, 성능 고려 사항, 대상 업무의 성격, 소프트웨어의 수행환경, 개발 담당자의 경험과 지식, 사용자의 요구사항, 컴파일러 이용 가능성, 컴파일러 가용성, 개발 정보시스템의 특성



- degree : 열
- cardinality : 행

# IP

## IP 주소 체계

### IPv4

- 주소크기 32bit
- 유니캐스트 / 멀티캐스트 / 브로드캐스트 사용
- 헤더가 가변적
- 클래스별로 네트워크와 호스트 주소의 길이가 다름
- 호스트 주소를 자동으로 설정하며 유니캐스트(Unicast)를 지원

### IPv6

- 주소크기 128bit
- 기존 IPv4의 주소 부족 문제를 해결하기위해 개발
- 인증성 / 기밀성 / 무결성 지원 (= 보안성 강화)

- 유니캐스트 / 애니캐스트 / 멀티캐스트 사용
- 헤더 40 octet의 고정된 길이
- 주소 자동설정 (Auto Configuration) 기능을 통해 손쉽게 이용자의 단말을 네트워크에 접속시킬수 있다
- 16비트씩 8부분의 16진수로 표시
- 2^128개의 주소를 표현할 수 있다
- 등급별 서비스별로 패킷을 구분할 수 있어 품질보장이 용이
- 확장기능을 통해 보안기능을 제공

### TCP / IP 계층 구조 동작과정

- ARP : IP 네트워크 상에서 IP주소를 MAC주소로 변환하는 프로토콜
-  ICMP : IP와 조합하여 통신중에 발생하는 오류의 처리와 전송경로변경 등을 위한 제어 메세지를 관히하는 역할을 하는 프로토콜
- ARP : 호스트의 IP주소를 호스트와 연결된 네트워크 접속 장치의 물리적 주소로 바꾸는 역할을 하는 프로토콜
- PPP : 점대점 데이터링크를 통해 3계층 프로토콜들을 캡슐화시켜 전송하는 프로토콜

### OSI 7계층

- 1계층 - 물리계층(Physical Layer)
  - Coax, Fiber, Wireless
- 2계층 - 데이터 링크계층 (DataLink Layer)
  - Ethernet, SLIP, PPP, FDDI, HDLC
- 3계층 - 네트워크 계층 (Network Layer)
  - IP, IPSec, ICMP, IGMP
- 4계층 - 전송 계층 (Transport Layer)
  - TCP, UDP, ECN, SCTP, DCCP
- 5계층 - 세션 계층 (Session Layer)
  - VARIOUS APIS, SOCKETS
- 6계층 - 표현 계층 (Presentation Layer)
  - SSL, FTP, IMAP, SSH
- 7계층 - 응용 계층 (Application Layer)
  - HTTP, FTP, IRC, SSH, DNS



- dekker algorithm 데커 알고리즘
  - 프로세스가 두개일 때 상호 배제를 보장하는 최초의 알고리즘
  - flag와 turn 변수를 사용하여 조정
- lamport algorithm 램퍼드 알고리즘
  - 프로세스 n개의 상호 배제 문제를 해결한 알고리즘
  - 프로세스에게 고유한 번호를 부여하고 번호를 기준으로 우선순위를 정하여 우선순위가 높은 프로세스가 먼저 임계구역에 진입하도록 구현
- peterson algorithm 피터슨 알고리즘
  - 프로세스가 두개일 때 상호 배제를 보장, 데커의 알고리즘과 유사하지만 상대방에게 진입 기회를 양보한다는 차이가 있고 보다 더 간단하게 구현됨
- Semaphore
  - 공유된 자원의 데이터 혹은 임계영역 등에 따라 여러 Process 혹은 Thread가 접근하는 것을 막아줌 (동기화 대상이 하나 이상)