- 예시를 참고하여 스스로 기준과 조합을 찾아가는게 좋음



- 아토믹 디자인 패턴은 정답은 아님
- 하지만 개발을 배우며 학습하는 관점에서는 정말 좋은 예시이자 방법론임
- 아토민 디자인 방법론을 구성하는 기본 단위(인터페이스) 에 정답이 있는 건지..

- React 스럽게 생각하며 / 회사의 도메인 컨텍스트를 생각하며 아토믹 디자인 방법론을 지킬 수 있을까 ? 가 문제라고 생각



### 리액트스러운 컴포넌트 생각하기

- React는 디자인을 바라보는 방식과 앱을 빌드하는 방식
- React로 사용자 인터페이스를 빌드하는 방법
  1. 컴포넌트라는 조각으로 분해
  2. 각 컴포넌트에 대해 서로 생김새가 다른 상태 정의
  3. 컴포넌트를 서로 연결해 데이터가 흐르도록 한다

### 결론

- 리액트 컴포넌트를 만들때 아토믹 디자인 패턴을 도입하는 것
- 아토믹 디자인 패턴을 구성하는 기준 + 리액트스러운 컴포넌트 조합
  - +@ 회사에서 추구하는 비즈니스 가치, 도메인 컨텍스트 고려
  - Time(시간), Project(프로젝트), Occasion(상황) 고려해야함
- 아토믹 디자인 패턴은 누군가가 만든 아토믹 디자인 방법론에 개발자가 원하는 디자인 패턴을 더한 것
- 아토믹 디자인 방법론이란 누군가가 화학적인 요소들을 html 요소들에 더해서 이러한 방법론이 있다고 정의한것 (?)
- 아토믹 디자인 패턴을 도입할 때 힘든 이유  = 인터페이스를 나누는 기준이 정답이 없고 사람마다 다름 왜냐면 아토믹 디자인 방법론을 설계한 저자가 정의한건 디자인 명세와 생김새, 방법론으로 정의했기 때문에 컴포넌트를 개발하는 사람들이 생각하는 것과 다름



도메인 컨텍스트란 ?



## CDD (Component-Driven Development)

> 컴포넌트 주도 개발 / 컴포넌트 중심으로 UI를 개발하는 방법론

- 컴포넌트 주위에 개발 프로세스를 고정하는 개발 방법론
- 컴포넌트 수준에서 시작해 페이지나 화면 수준에서 끝나는것 (bottom up)
- 점점 더 많은 회사들이 고품질의 보다 복잡한 사용자 인터페이스를 구축하기 위해 채택하고 있는 개발 방법론

## 상향식 컴포넌트 개발 (Bottom Up)

- 가장 작은 단위의 하위 컴포넌트들을 먼저 개발

- 이런 작은 하위 컴포넌트들을 조합하여 전체적인 컴포넌트를 완성

- 일반 사용자뿐만 아니라 개발자도 사용할 수 있는 컴포넌트를 고려해야함

- YAGNI

  - 숙련도가 부족하다면 YAGNI에 빠지기 쉽다

- 예시)

  - 작고 하찮을정도로 귀여운 컴포넌트 ===> Next.js Page

  - Atom ======> Page

## 하향식 컴포넌트 개발 (Top Down)

- 하향식 컴포넌트 개발은 전체 시스템의 큰 구성 요소들을 먼저 개발
- 이후에 중복되는 작은 컴포넌트를 분리하거나 공동 혹은 교차되는 컴포넌트를 분리
- 전체 시스템의 디자인과 구조를 먼저 구성하고 이를 바탕으로 세부적인 요소들을 개발
- 르블랑의 법칙 (Leblance's Law)
  - 한번 작성한 쓰레기 코드를 나중에 수정하는 일은 결코 없다

- 예시
  - Next.js Page ===> 작고 하찮을정도로 귀여운 컴포넌트
  - Page(페이지) => 템플릿 => 올가니즘 => 몰레큘 => Atom



# 제어 컴포넌트와 비제어 컴포넌트

## Controlled Component (제어 컴포넌트)

> Push & SIngle Source of Truth

- React에 값이 완전히 제어되는 Input Element - input handler에 value를 onchange로 단 것
- State를 값으로 넘기고 그 State을 다를수 있는 핸들러를 콜백으로 넘긴다
- 값을 -로 받는다
- 사용자가 입력하면 값을 계속 push 하는  것
- 진실의 원천이 유지되기 쉬움 (?)
- DOM에 바뀌는 상태, React 상태, DOM 객체에 들어있는 값이 계속 진실의 원천으로 동기화가 됨
- 내가 제어하고 내가 push 하고 진실의 원천으로 계쏙 상태가 유지된다

```js
// input의 값은 항상 React state의 값
<input value={value} onChange={handeChange}/>
```

## Uncontrolled Component (비제어 컴포넌트)

> Pull & get State

- 전통적인 HTML처럼 DOM에 제어되는 Input Element
- 오직 사용자만 값과 상호작용
- 값을 -로 사용한다

- 내가 제어하지 않고 필요할때 상태를 꺼내옴
- 상태를 꺼내오기 전엔 렌더링이 일어나지 않음

```js
<input value={value} onChange={handleChange} ref={inputRef}/>
```

































